#include <iostream>
#include <cstdlib>
#include <vector>
#include <algorithm>

using namespace std;

#define MAX_N 13
#define MAX_CORE 13
#define LINE_INF 13*13+100

enum MapComponent {EMPTY,CORE,LINE,DISCONNECT_STOP};
MapComponent core_map[MAX_N][MAX_N];

vector<pair<int, int>> point_arr;

class ResultStruct {
public:
	int connected_core;
	int line_sum;

	ResultStruct(int in_core,int in_sum) {
		connected_core = in_core;
		line_sum = in_sum;
	}

	void plusLineSum(int in_sum) {
		line_sum += in_sum;
	}

	void plusConnectedCore(int in_core) {
		connected_core += in_core;
	}

	friend bool operator > (ResultStruct & x,ResultStruct &a) {
		if (x.connected_core > a.connected_core) {
			return true;
		}
		else if (x.connected_core < a.connected_core) {
			return false;
		}
		else if (x.line_sum > a.line_sum) {
			return true;
		}
		else return false;
	}

	friend ResultStruct operator + (ResultStruct x, ResultStruct &a) {
		x.connected_core += a.connected_core;
		x.line_sum += a.line_sum;
		return x;
	}

	ResultStruct operator = (ResultStruct a) {
		this->connected_core += a.connected_core;
		this->line_sum += a.line_sum;
		return *this;
	}

	bool isZero(void) {
		if (connected_core == 0 && line_sum == 0) return true;
		else return false;
	}
};

enum _direction_enum { UP, DOWN, LEFT, RIGHT };

class Direction {
private:
	int dir_int;
	
public:
	Direction() { dir_int = -1; };
	Direction(int in_dir) {
		dir_int = in_dir;
	}
	void setDirectionByInt(int in_dir) {
		dir_int = in_dir;
	}
	void setDirection(_direction_enum dir) {
		dir_int = (int)dir;
	}
	pair<int, int> getAdder(void) {
		pair<int, int> arr[] = { {-1,0},{1,0},{0,-1},{0,1} };
		if (dir_int == -1) {
			printf("Error: Direction Class getAdder is used without direction setting\n");
			return arr[0];
		}
		return arr[dir_int];
	}
	
};

#define isInBoundary(pair_point, size) (pair_point.first >= 0 && pair_point.first <= size-1 && pair_point.second >= 0 && pair_point.second <= size-1)

pair<int, int> pairPlus(pair<int, int> a, pair<int, int> b) {
	return { a.first + b.first,a.second + b.second };
}

ResultStruct ConnectToDir(Direction dir, pair<int, int> cur_point,int n) {
	pair<int, int> adder = dir.getAdder();
	pair<int, int> moving_point = cur_point;
	ResultStruct result(0, 0);

	moving_point = pairPlus(moving_point, adder);

	bool fail_to_connect = false;

	while (isInBoundary(moving_point, n)) {
		if (core_map[moving_point.first][moving_point.second] == CORE
			|| core_map[moving_point.first][moving_point.second] == LINE) {
			
			fail_to_connect = true;

			if (core_map[moving_point.first][moving_point.second] == LINE)
				core_map[moving_point.first][moving_point.second] = DISCONNECT_STOP;
			
			break;
		}

		if (core_map[moving_point.first][moving_point.second] == EMPTY) {
			core_map[moving_point.first][moving_point.second] = LINE;
			result.plusLineSum(1);
		}

		moving_point = pairPlus(moving_point, adder);
	}

	if (fail_to_connect == true) {
		DisconnectToDir(dir, cur_point, n);
		ResultStruct empty_result(0, 0);
		return empty_result;
	}

	result.plusConnectedCore(1);
	return result;
}

void DisconnectToDir(Direction dir, pair<int, int> cur_point,int n) {
	pair<int, int> adder = dir.getAdder();
	pair<int, int> moving_point = cur_point;
	moving_point = pairPlus(moving_point, adder);
	while (isInBoundary(moving_point, n)) {
		if (core_map[moving_point.first][moving_point.second] == CORE
			|| core_map[moving_point.first][moving_point.second] == EMPTY) break;

		if (core_map[moving_point.first][moving_point.second] == DISCONNECT_STOP) {
			core_map[moving_point.first][moving_point.second] = LINE;
			break;
		}

		if (core_map[moving_point.first][moving_point.second] == LINE) 
			core_map[moving_point.first][moving_point.second] = EMPTY;

		moving_point = pairPlus(moving_point, adder);
	}
}

ResultStruct findMinConnectLineSum(ResultStruct cur_result, int idx,int n) {
	ResultStruct future_result(0, 0);

	if (idx >= n) return future_result;
	
	for (int dir = 0; dir < 4; dir++) {
		bool disconnect_needed = false;
		
		Direction para_dir(dir);

		ResultStruct result_to_dir = ConnectToDir(para_dir, point_arr[idx],n);
		if (result_to_dir.isZero() == false) disconnect_needed = true;

		result_to_dir = result_to_dir + cur_result;
		ResultStruct tmp_result = findMinConnectLineSum(result_to_dir, idx + 1,n);
		if (tmp_result > future_result) future_result = tmp_result;

		if (disconnect_needed == true) DisconnectToDir((Direction)dir, point_arr[idx],n);
	}

	return future_result;
}

int main(void) {
	int T;
	cin >> T;
	for (int t = 0; t < T; t++) {
		memset(core_map, 0, sizeof(core_map));
		point_arr.clear();

		int N;
		cin >> N;

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				int c;
				cin >> c;
				core_map[i][j] = (MapComponent)c;

				if (c == 1) point_arr.push_back(make_pair(i, j));
			}
		}

		ResultStruct cur(0, 0);
		cur = findMinConnectLineSum(cur, 0, N);

		cout << "#" << t + 1 << " " << cur.connected_core << endl;
	}

	return 0;
}
