#define DEBUG false

#include <iostream>
#include <cstdlib>
#include <vector>
#include <algorithm>

using namespace std;

#define MAX_N 13
#define MAX_CORE 13
#define LINE_INF 13*13+100

enum Connection{LEFT,RIGHT,UP,DOWN,NOT};

struct CoreNode {
	int row; int col;
	Connection connect;
	int line;
};

vector<CoreNode> core_arr;

struct Result {
	int connected_core;
	int line_sum;
};

bool isCanConnect(int idx,Connection dir) {
	bool cant_connect = false;
	
	for (int i = 0; i < core_arr.size(); i++) {
		if (i == idx) continue;
		
		switch (dir) {
		case LEFT: {
			if (core_arr[i].col < core_arr[idx].col) {
				if ((core_arr[i].row == core_arr[idx].row)
					|| (core_arr[i].row < core_arr[idx].row && core_arr[i].connect == DOWN)
					|| (core_arr[i].row > core_arr[idx].row && core_arr[i].connect == UP)) {
					cant_connect = true;
				}
			}
		}break;
		case RIGHT: {
			if (core_arr[i].col > core_arr[idx].col) {
				if ((core_arr[i].row == core_arr[idx].row)
					|| (core_arr[i].row < core_arr[idx].row && core_arr[i].connect == DOWN)
					|| (core_arr[i].row > core_arr[idx].row && core_arr[i].connect == UP)) {
					cant_connect = true;
				}
			}
		}break;
		case UP: {
			if (core_arr[i].row < core_arr[idx].row) {
				if ((core_arr[i].col == core_arr[idx].col)
					|| (core_arr[i].col < core_arr[idx].col && core_arr[i].connect == RIGHT)
					|| (core_arr[i].col > core_arr[idx].col && core_arr[i].connect == LEFT)) {
					cant_connect = true;
				}
			}
		}break;
		case DOWN: {
			if (core_arr[i].row > core_arr[idx].row) {
				if ((core_arr[i].col == core_arr[idx].col)
					|| (core_arr[i].col < core_arr[idx].col && core_arr[i].connect == RIGHT)
					|| (core_arr[i].col > core_arr[idx].col && core_arr[i].connect == LEFT)) {
					cant_connect = true;
				}
			}
		}
		}
	}

	return !cant_connect;
}

int getLineLength(int idx,int n) {
	int result = 0;
	
	switch (core_arr[idx].connect) {
	case LEFT: {
		result = core_arr[idx].col;
	}break;
	case RIGHT: {
		result = n-1 - core_arr[idx].col;
	}break;
	case UP: {
		result = core_arr[idx].row;
	}break;
	case DOWN: {
		result = n - 1 - core_arr[idx].row;
	}break;
	case NOT: {
		result = 0;
	}
	}

	return result;
}

Result FindMaxCorConnection(int idx,int n) {
	if (idx >= core_arr.size()) {
		return { 0,0 };
	}

	Result result = { 0,0 };

	for (int dir = 0; dir < 4; dir++) {
		Connection target_direction = (Connection)dir;

		Result toDirResult;
		if (isCanConnect(idx, target_direction) == true) {
			core_arr[idx].connect = target_direction;
			toDirResult = FindMaxCorConnection(idx + 1, n);
			toDirResult.connected_core += 1;
			toDirResult.line_sum += getLineLength(idx, n);
		}
		else {
			core_arr[idx].connect = NOT;
			toDirResult = FindMaxCorConnection(idx + 1, n);
		}

		if (result.connected_core < toDirResult.connected_core
			|| (result.connected_core == toDirResult.connected_core && result.line_sum > toDirResult.line_sum)) {
			result = toDirResult;
		}
	}

	core_arr[idx].connect = NOT;
	
	return result;
}

int main(void) {
	int T;
	cin >> T;
	for (int t = 0; t < T; t++) {
		int N;
		cin >> N;

		core_arr.clear();
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				int c;
				cin >> c;
				
				if (c == 1) core_arr.push_back({ i,j,NOT,0 });
			}
		}

		printf("%d\n", core_arr.size());

		Result result;
		result = FindMaxCorConnection(0, N);

		cout << "#" << t + 1 << " " << result.line_sum << endl;
	}

	return 0;
}
